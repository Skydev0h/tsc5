#include "imports/stdlib.fc";

() ret() impure asm "RET";
() return_if(int cond) impure asm "IFRET";
(slice) udict_get_or_throw_400?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "400 THROWIFNOT";

cell get_storage() inline {
    return get_data().begin_parse().preload_ref();
}

cell wrap_storage(int version_id, cell storage) inline {
    ;; add additional data required for versioning in this cell
    return begin_cell()
        .store_uint(version_id, 32)
        .store_ref(storage)
        .end_cell();
}

;; Return the current version of the smart contract
int version() method_id {
    return get_data().begin_parse().preload_uint(32);
}

;; <<<<< Custom version-specific code begins

cell process_message(cell storage, int msg_value, int balance, cell in_msg_full, slice in_msg_body) impure {
    slice cs = storage.begin_parse();
    int current_amount = cs.preload_uint(32);
    return begin_cell().store_uint(current_amount + 1, 32).end_cell();
}

cell migrate_one(cell old_storage) { return old_storage; }

;; Custom version-specific code ends >>>>>

() recv_internal(int msg_value, int balance, cell in_msg_full, slice in_msg_body) impure {
    ;; if (in_msg_body.slice_empty?()) { return(); } ;; deploy / ordinary
    return_if(in_msg_body.slice_empty?());

    int expected_version = in_msg_body~load_uint(32);

    if (expected_version == 0) {
        set_data(wrap_storage(1, get_data()));
        {-
        ret();
        expected_version~impure_touch();
        in_msg_body~impure_touch();
        in_msg_full~impure_touch();
        balance~impure_touch();
        msg_value~impure_touch();
        -}
        return ();
    }

    cell expected_code = in_msg_body~load_maybe_ref();
    cell migrations = in_msg_body~load_dict();
    cell payload = in_msg_body.preload_ref();

    slice ds = get_data().begin_parse();
    int version = ds~load_uint(32);
    cell storage = ds.preload_ref();

    if (version != expected_version) {

        while (version != expected_version) {
            ;; ~dump([version, expected_version]);
            slice mig = migrations.udict_get_or_throw_400?(32, version);
            ;; throw_unless(400, found);
            ;; mig~dump();
            int next = mig~load_uint(32);
            cell mc = mig.preload_maybe_ref();
            ;; ~dump([next, mc]);
            ifnot (mc.null?()) {
                set_c3(mc.begin_parse().bless());
                storage = migrate_one(storage);
            }
            ;; throw_if(400, version == next);
            version = next;
        }

        throw_if(200, expected_code.null?());
        set_c3(expected_code.begin_parse().bless());
        set_code(expected_code);
        {-
        set_data(begin_cell()
            .store_uint(version, 32)
            .store_ref(storage)
            .end_cell()
        );
        commit();
        -}
    }

    storage = process_message(storage, msg_value, balance, in_msg_full, payload.begin_parse());

    set_data(wrap_storage(version, storage));

    {-
    ret();
    migrations~impure_touch();
    expected_code~impure_touch();
    expected_version~impure_touch();
    -}
}
