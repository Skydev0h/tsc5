#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}

int tlen(tuple list) asm "TLEN";

forall X -> X tget(tuple t, int index) asm "INDEXVAR";
forall X -> (tuple, X) tpop(tuple t) asm "TPOP";

forall X -> tuple tset(tuple t, X value, int index) asm "SETINDEXVAR";
forall X -> (tuple, ()) ~tset(tuple t, X value, int index) asm "SETINDEXVAR";

forall X, Y, Z, W, V -> (X, Y, Z, W, V) untuple5([X, Y, Z, W, V] t) asm "5 UNTUPLE";

;; . X S E ? !

{-
() walker(tuple maze, int x, int y, int a, int s) impure inline_ref {
    ;; int c = maze.at(y).at(x);
    ;; ~dump([x, y, a, s, c]);
    if (s != 0) {
        maze~tset(maze.tget(y).tset("!"u, x), y);
    }
    int y' = max(y - 1, 0);
    int n'' = n';
    repeat (min(y + 1, m') - y' + 1) {
        tuple t = maze.at(y');
        int x' = max(x - 1, 0);
        repeat (min(x + 1, n'') - x' + 1) {
            int c' = t.at(x');
            ;; ~dump([x', y', c']);
            if (c' == "."u) {
                walker(maze, x', y', a, s + 1);
            }
            if (c' == "?"u) {
                if (a != 0) {
                    walker(maze, x', y', a - 1, s + 1);
                }
            }
            if (s >= 'len) {
                return ();
            }
            if (c' == "E"u) {
                ;; ~dump([s, maze]);
                if (s + 1 < 'len) {
                    'len = s + 1;
                    'maze = maze;
                }
                return ();
            }
            x' += 1;
        }
        y' += 1;
    }
}
-}

;;-1  obs  len  maze
(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {

    accept_message();

    int Sx = 0; int Sy = 0; int n? = 0;
    int n' = maze.tget(0).tlen();
    int m' = maze.tlen();
    int y = 0;
    repeat (m') {
        tuple t = maze.at(y);
        int x = 0;
        repeat (n') {
            int c = t.at(x);
            if (c == "S"u) { Sx = x; Sy = y; }
            if (c == "?"u) { n? += 1; }
            x += 1;
        }
        y += 1;
    }

    m' = m' - 1;
    n' = n' - 1;

    int 'len = 0x100000000;
    tuple 'maze = null();
    tuple stk = null();
    int 'obs = 'len;
    stk = cons([maze, Sx, Sy, 0, 0], stk);

    do {

        [tuple, int, int, int, int] next = stk~list_next();
        (tuple mz, int x, int y, int ob, int le) = untuple5(next);
        if (le != 0) { mz~tset(mz.tget(y).tset("!"u, x), y); }
        int y' = y - 1;
        repeat(3) {
            if ((y' >= 0) & (y' <= m')) {
                tuple t = mz.at(y');
                int x' = x - 1;
                repeat(3) {
                    if ((x' >= 0) & (x' <= n')) {
                        int c' = t.at(x');
                        ;; ~dump([x', y', c']);
                        if (c' == "."u) {
                            stk = cons([mz, x', y', ob, le + 1], stk);
                        }
                        elseif (c' == "?"u) {
                            stk = cons([mz, x', y', ob + 1, le + 1], stk);
                        }
                        elseif (c' == "E"u) {
                            ;; ~dump([s, maze]);
                            if ((ob < 'obs) | ((ob == 'obs) & (le + 1 < 'len))) {
                                'len = le + 1;
                                'obs = ob;
                                'maze = mz;
                            }
                        }
                        if (le >= 'len) {
                            x' = 256;
                            y' = 256;
                        }
                    }
                    x' += 1;
                }
            }
            y' += 1;
        }

    } until(stk.null?());

    ifnot ('maze.null?()) {
        return (-1, 'obs, 'len, 'maze);
    }

    return (-1, 0, 0, null());
}
