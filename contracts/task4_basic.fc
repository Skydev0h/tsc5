#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}

int tlen(tuple list) asm "TLEN";

forall X -> X tget(tuple t, int index) asm "INDEXVAR";
forall X -> (tuple, X) tpop(tuple t) asm "TPOP";

forall X -> tuple tset(tuple t, X value, int index) asm "SETINDEXVAR";
forall X -> (tuple, ()) ~tset(tuple t, X value, int index) asm "SETINDEXVAR";

forall X, Y, Z, W, V -> (X, Y, Z, W, V) untuple5([X, Y, Z, W, V] t) asm "5 UNTUPLE";
forall T1, T2, T3, T4, T5, T6, T7 -> (T1, T2, T3, T4, T5, T6, T7) untuple7([T1, T2, T3, T4, T5, T6, T7] t) asm "7 UNTUPLE";

;; . X S E ? !

{-
() walker(tuple maze, int x, int y, int a, int s) impure inline_ref {
    ;; int c = maze.at(y).at(x);
    ;; ~dump([x, y, a, s, c]);
    if (s != 0) {
        maze~tset(maze.tget(y).tset("!"u, x), y);
    }
    int y' = max(y - 1, 0);
    int n'' = n';
    repeat (min(y + 1, m') - y' + 1) {
        tuple t = maze.at(y');
        int x' = max(x - 1, 0);
        repeat (min(x + 1, n'') - x' + 1) {
            int c' = t.at(x');
            ;; ~dump([x', y', c']);
            if (c' == "."u) {
                walker(maze, x', y', a, s + 1);
            }
            if (c' == "?"u) {
                if (a != 0) {
                    walker(maze, x', y', a - 1, s + 1);
                }
            }
            if (s >= 'len) {
                return ();
            }
            if (c' == "E"u) {
                ;; ~dump([s, maze]);
                if (s + 1 < 'len) {
                    'len = s + 1;
                    'maze = maze;
                }
                return ();
            }
            x' += 1;
        }
        y' += 1;
    }
}
-}

;;-1  obs  len  maze
(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {

    accept_message();

    int Sx = 0; int Sy = 0;
    int n' = n; ;;maze.tget(0).tlen();
    int m' = m; ;;maze.tlen();
    int y = 0;
    repeat (m') {
        tuple t = maze.at(y);
        int x = 0;
        repeat (n') {
            int c = t.at(x);
            if (c == "S"u) { Sx = x; Sy = y; }
            x += 1;
        }
        y += 1;
    }

    tuple hm = empty_tuple();
    tuple hr = empty_tuple();
    repeat (n') { hr~tpush('hier); }
    repeat (m') { hm~tpush(hr); }

    m' = m' - 1;
    n' = n' - 1;

    int 'hier = 1 << 128;
    int 'len = 'hier;
    int 'obs = 'hier;
    tuple 'maze = null();
    tuple stk = null();
    ;; tuple nstk = null();
    stk = cons([maze, Sx, Sy, 0, 0, 0, 0], stk);

    {-
    do {

        stk = nstk;
        nstk = null();
    -}

        do {
            [tuple, int, int, int, int, int, int] next = stk~list_next();
            (tuple mz, int x, int y, int dx, int dy, int ob, int le) = untuple5(next);
            if (le != 0) {
                mz~tset(mz.tget(y).tset("!"u, x), y);
            }
            int hier = (le + 1) | (ob << 32);
            hm~tset(hm.tget(y).tset(hier, x), y);
            int y' = y - 1;
            repeat (3) {
                if ((y' >= 0) & (y' <= m')) {
                    tuple t = mz.at(y');
                    tuple h = hm.at(y');
                    int x' = x - 1;
                    repeat (3) {
                        if ((x' >= 0) & (x' <= n')) {
                            int c' = t.at(x');
                            int h' = h.at(x');
                            if (hier < h') {
                                ;; ~dump([x', y', c']);
                                if (c' == "."u) {
                                    stk = cons([mz, x', y', ob, le + 1], stk);
                                }
                                elseif (c' == "?"u) {
                                    stk = cons([mz, x', y', ob + 1, le + 1], stk);
                                }
                                elseif (c' == "E"u) {
                                    ;; ~dump([s, maze]);
                                    if (hier < 'hier) {
                                        'hier = hier;
                                        'len = le + 1;
                                        'obs = ob;
                                        'maze = mz;
                                    }
                                }
                            }
                            if (le >= 'len) {
                                x' = 256;
                                y' = 256;
                            }
                        }
                        x' += 1;
                    }
                }
                y' += 1;
            }

        } until (stk.null?());

    ;; } until (nstk.null?());

    ifnot ('maze.null?()) {
        return (-1, 'obs, 'len, 'maze);
    }

    return (-1, 0, 0, null());
}
